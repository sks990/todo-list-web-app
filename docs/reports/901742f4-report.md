# 작업 보고서: 데이터 타입 및 문자열 계산 방식 기술 명세서 작성

## 메타데이터
- **태스크 ID**: 901742f4-cc3b-46ea-8d9b-d766dbeaf432
- **타입**: documentation
- **우선순위**: low
- **담당 에이전트**: Tech Lead
- **완료 시간**: 2026-02-11T05:24:14.809Z

## 태스크 설명
DB Multi-byte 문자 처리 방식(Char vs Byte) 및 공백 문자에 대한 유효성 검사 표준 정책 문서화

---
*Follow-up from task: 비즈니스 정책 검증 로직 동기화 전략 수립*

## 작업 내용
반갑습니다. Tech Lead AI Agent입니다.

데이터베이스 내 Multi-byte 문자 처리 방식(CHAR vs BYTE)의 정합성을 확보하고, 공백 문자 유효성 검사에 대한 표준을 정의하는 기술 명세 및 샘플 구현 코드를 작성하였습니다. 이 작업은 데이터 무결성을 유지하고 비즈니스 로직의 일관성을 보장하는 데 중점을 둡니다.

```filepath:docs/standards/data-type-and-validation-spec.md
# 데이터 타입 및 문자열 계산 방식 기술 명세서

## 1. 개요
본 문서는 데이터베이스 저장 시 Multi-byte 문자 처리 방식과 공백 문자 유효성 검사에 대한 표준 정책을 정의합니다. 시스템 간 데이터 전송 및 저장 시 발생할 수 있는 데이터 잘림(Truncation) 및 정합성 오류를 방지하는 것을 목적으로 합니다.

## 2. 문자열 길이 계산 표준 (Length Semantics)

### 2.1 DB 설정 및 선언 방식
*   **표준 방식**: `CHAR` 기반 길이 산정 (Character Semantics)
*   **이유**: 다국어(한글 등) 환경에서 바이트 수 계산으로 인한 비즈니스 로직의 복잡성을 제거하고, 사용자 입장에서의 글자 수를 기준으로 데이터 모델을 설계함.
*   **DB 설정 예시 (Oracle)**: `NLS_LENGTH_SEMANTICS = CHAR`
*   **컬럼 선언**: `VARCHAR2(100 CHAR)`

### 2.2 Multi-byte 처리 규칙
*   UTF-8 인코딩을 기준으로 하며, 한글은 3바이트를 차지하지만 논리적 길이는 1로 처리함.
*   외부 시스템 연동(Legacy, 대외기관) 시 Byte 기반 통신이 필요할 경우 별도의 `ByteLengthValidator`를 거쳐야 함.

## 3. 공백 문자 유효성 검사 정책 (Whitespace Policy)

### 3.1 Trim 정책
*   **Input Stage**: 모든 문자열 입력 값은 Leading/Trailing 공백을 제거(Trim)하는 것을 원칙으로 함.
*   **Exception**: 주소, 상세 설명 등 공백이 의미를 가지는 필드는 예외로 두되, 관리자가 승인한 필드에 한함.

### 3.2 빈 문자열 vs NULL
*   **표준**: 빈 문자열(`""`)은 내부적으로 `NULL`로 처리하거나, 엄격하게 구분해야 하는 경우 DB 제약 조건을 통해 관리함. (Oracle의 경우 빈 문자열은 NULL과 동일함)

---

## 4. 아키텍처 가이드라인

1.  **Presentation Layer**: UI 단에서 `maxlength` 속성을 통해 1차 검증.
2.  **Application Layer**: 엔티티 매핑 시 커스텀 어노테이션을 통한 유효성 검사 수행.
3.  **Persistence Layer**: DB 컬럼 정의 시 반드시 `CHAR` 세만틱 명시.
```

```filepath:src/main/java/com/techlead/standard/validation/StringPolicyValidator.java
package com.techlead.standard.validation;

import java.nio.charset.StandardCharsets;

/**
 * 데이터 타입 및 문자열 계산 방식 정책에 따른 유효성 검사 유틸리티
 */
public class StringPolicyValidator {

    /**
     * 논리적 글자 수 검증 (Character-based)
     * DB의 VARCHAR2(N CHAR) 정책에 대응함.
     */
    public static boolean isValidCharLength(String value, int maxLength) {
        if (value == null) return true;
        return value.length() <= maxLength;
    }

    /**
     * 물리적 바이트 수 검증 (Byte-based)
     * 외부 인터페이스 등 Byte 기준 통신 시 사용. UTF-8 기준.
     */
    public static boolean isValidByteLength(String value, int maxBytes) {
        if (value == null) return true;
        return value.getBytes(StandardCharsets.UTF_8).length <= maxBytes;
    }

    /**
     * 표준 공백 처리 및 유효성 검사
     * 필수값인 경우 공백만 있는 문자열은 false 반환
     */
    public static String sanitize(String value) {
        if (value == null) return null;
        String trimmed = value.trim();
        return trimmed.isEmpty() ? null : trimmed;
    }

    /**
     * 문자열이 비어있는지 확인 (공백 포함)
     */
    public static boolean isBlank(String value) {
        return value == null || value.trim().isEmpty();
    }
}
```

```filepath:src/main/java/com/techlead/standard/annotation/StringPolicy.java
<ctrl60>package com.techlead.standard.annotation;

import java.lang.annotation.*;

/**
 * 엔티티 필드에 적용하여 문자열 정책을 명시하기 위한 어노테이션
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface StringPolicy {
    int maxLength() default 255;
    boolean useByteCheck() default false; // false 면 Character 기준, true 면 Byte 기준
    boolean allowLeadingTrailingSpaces() default false;
}
```

### 리포트 및 분석 결과

#### 1. 생성/수정 파일 목록
*   `docs/standards/data-type-and-validation-spec.md`: Multi-byte 및 공백 처리 표준 정의서.
*   `src/main/java/com/techlead/standard/validation/StringPolicyValidator.java`: 표준 정책을 강제하기 위한 검증 유틸리티.
*   `src/main/java/com/techlead/standard/annotation/StringPolicy.java`: 선언적 프로그래밍을 위한 메타데이터 어노테이션.

#### 2. 핵심 구현 결정 사항
*   **Character Semantics 우선**: 하드웨어 가성비보다 개발 생산성과 데이터 일관성을 위해 DB와 애플리케이션 모두 '글자 수' 기준(Char-based length)을 표준으로 채택했습니다.
*   **Sanitization 전략**: 데이터 입력 단계에서 `trim`을 기본으로 적용하여 불필요한 공백으로 인한 인덱스 스캔 효율 저하 및 정합성 오류를 원천 차단했습니다.
*   **유연성 확보**: 외부 시스템 연동을 위해 Byte 단위 체크 기능을 `StringPolicyValidator`에 포함하여 특수 케이스에 대응 가능하도록 설계했습니다.

#### 3. 잠재적 리스크 및 의존성
*   **DB 호환성**: Oracle은 `CHAR` 세만틱을 명시적으로 지원하지만, 다른 RDBMS(MySQL, PostgreSQL 등)는 기본 글자 수 기반이므로 환경에 따른 설정 확인이 필요합니다.
*   **레거시 데이터**: 기존 시스템의 데이터가 Byte 기준으로 저장되어 있을 경우, 데이터 이전(Migration) 시 길이 오버플로우가 발생할 수 있으므로 이행 전략 수립이 병행되어야 합니다.

#### 4. 향후 권장 사항
*   **AOP 통합**: `StringPolicy` 어노테이션을 기반으로 `RequestBody`나 `Entity` 저장 전 자동으로 `sanitize` 및 `validate`를 수행하는 Aspect 구현을 권장합니다.
*   **CI/CD 연동**: DB 스키마 변경 시(DDL) `BYTE` 타입 사용을 감지하여 경고를 발생시키는 Linting 규칙 추가가 필요합니다.

PM님, 위 명세와 코드를 통해 시스템 전반의 문자열 처리 표준을 확립할 수 있습니다. 검토 부탁드립니다.

## 다음 단계
- [ ] PM 리뷰 대기
- [ ] 코드 리뷰 진행
- [ ] 테스트 검증
- [ ] 배포 승인

---
*이 보고서는 AI 에이전트에 의해 자동 생성되었습니다.*
