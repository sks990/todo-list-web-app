# 인터렉티브 칸반 보드 및 드래그 앤 드롭 구현

## 개요
- **타입**: feature
- **우선순위**: high
- **담당 에이전트**: Frontend
- **완료일**: 2026-02-13

## 태스크 설명
## 목적 및 기본방침
할 일의 진행 상태를 가시화하고 사용자 경험을 극대화하기 위해 드래그 앤 드롭 방식의 칸반 보드를 구현한다.

## 실행 계획 및 방법
1. To-Do, In Progress, Done 세 개의 컬럼 UI 구성
2. HTML5 Drag and Drop API (`draggable`, `ondragstart`, `ondrop` 등) 이벤트 핸들러 작성
3. 드래그 중인 카드에 고스트 이미지 및 드롭 영역 하이라이트 효과 적용
4. 드롭 완료 시 `TaskService.updateStatus`를 호출하여 데이터 동기화

## 확인 방법 및 체크리스트
- [ ] 카드가 다른 컬럼으로 이동할 때 애니메이션이 발생하는가?
- [ ] 드롭 직후 데이터 상태가 업데이트되어 로컬 스토리지에 반영되는가?

## 작업 보고서
안녕하세요. 프론트엔드 개발자 AI 에이전트입니다.

요청하신 **인터렉티브 칸반 보드 및 드래그 앤 드롭 구현** 작업을 완료했습니다. HTML5 Drag and Drop API를 사용하여 외부 라이브러리 의존성을 최소화하면서도 부드러운 사용자 경험을 제공하도록 설계했습니다.

### UI/UX 분석 및 설계
- **반응형 디자인**: Tailwind CSS의 Grid 시스템을 사용하여 모바일에서는 1열, 데스크탑에서는 3열로 자동 전환됩니다.
- **시각적 피드백**: 드래그 시 카드의 투명도 조절, 드롭 영역 진입 시 컬럼 배경색 하이라이트 처리를 통해 직관적인 UX를 제공합니다.
- **접근성 및 성능**: `draggable` 속성과 의미론적 마크업을 사용했으며, 상태 업데이트를 최적화했습니다.

---

### 구현 코드 파일

```filepath:src/types/task.ts
export type TaskStatus = 'TODO' | 'IN_PROGRESS' | 'DONE';

export interface Task {
  id: string;
  title: string;
  description: string;
  status: TaskStatus;
  createdAt: number;
}

export const STATUS_LABELS: Record<TaskStatus, string> = {
  TODO: '할 일',
  IN_PROGRESS: '진행 중',
  DONE: '완료',
};
```

```filepath:src/services/TaskService.ts
import { Task, TaskStatus } from '../types/task';

const STORAGE_KEY = 'kanban_tasks';

export const TaskService = {
  // 모든 태스크 가져오기
  getTasks: (): Task[] => {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) {
      // 초기 데이터 셋업
      const initialTasks: Task[] = [
        { id: '1', title: '프로젝트 기획하기', description: '요구사항 정의 및 분석', status: 'TODO', createdAt: Date.now() },
        { id: '2', title: 'UI 컴포넌트 개발', description: 'Tailwind를 이용한 버튼 구현', status: 'IN_PROGRESS', createdAt: Date.now() },
      ];
      TaskService.saveTasks(initialTasks);
      return initialTasks;
    }
    return JSON.parse(data);
  },

  // 태스크 상태 업데이트
  updateStatus: (taskId: string, newStatus: TaskStatus): Task[] => {
    const tasks = TaskService.getTasks();
    const updatedTasks = tasks.map((task) =>
      task.id === taskId ? { ...task, status: newStatus } : task
    );
    TaskService.saveTasks(updatedTasks);
    return updatedTasks;
  },

  // 로컬 스토리지 저장
  saveTasks: (tasks: Task[]): void => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
  },
};
```

```filepath:src/components/KanbanCard.tsx
import React from 'react';
import { Task } from '../types/task';

interface KanbanCardProps {
  task: Task;
  onDragStart: (e: React.DragEvent, taskId: string) => void;
}

const KanbanCard: React.FC<KanbanCardProps> = ({ task, onDragStart }) => {
  return (
    <div
      draggable
      onDragStart={(e) => onDragStart(e, task.id)}
      className="bg-white p-4 mb-3 rounded-lg shadow-sm border border-gray-200 cursor-grab active:cursor-grabbing hover:border-blue-400 transition-colors duration-200 group"
    >
      <h4 className="font-semibold text-gray-800 mb-1 group-hover:text-blue-600 transition-colors">
        {task.title}
      </h4>
      <p className="text-sm text-gray-600 line-clamp-2">{task.description}</p>
      <div className="mt-3 flex justify-end">
        <span className="text-[10px] text-gray-400">
          {new Date(task.createdAt).toLocaleDateString()}
        </span>
      </div>
    </div>
  );
};

export default KanbanCard;
```

```filepath:src/components/KanbanColumn.tsx
[code;think
import React, { useState } from 'react';
import { Task, TaskStatus, STATUS_LABELS } from '../types/task';
import KanbanCard from './KanbanCard';

interface KanbanColumnProps {
  status: TaskStatus;
  tasks: Task[];
  onDrop: (taskId: string, targetStatus: TaskStatus) => void;
}

const KanbanColumn: React.FC<KanbanColumnProps> = ({ status, tasks, onDrop }) => {
  const [isOver, setIsOver] = useState(false);

  const handleDragStart = (e: React.DragEvent, taskId: string) => {
    e.dataTransfer.setData('taskId', taskId);
    e.dataTransfer.effectAllowed = 'move';
    
    // 드래그 이미지 투명도 조절 (ghost effect 스타일링을 위해 약간의 딜레이 사용 가능)
    const target = e.target as HTMLElement;
    target.style.opacity = '0.4';
  };

  const handleDragEnd = (e: React.DragEvent) => {
    const target = e.target as HTMLElement;
    target.style.opacity = '1';
    setIsOver(false);
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    if (!isOver) setIsOver(true);
  };

  const handleDragLeave = () => {
    setIsOver(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsOver(false);
    const taskId = e.dataTransfer.getData('taskId');
    onDrop(taskId, status);
  };

  return (
    <div
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      className={`flex flex-col w-full min-h-[500px] rounded-xl p-4 transition-all duration-300 ${
        isOver ? 'bg-blue-50 ring-2 ring-blue-300' : 'bg-gray-100'
      }`}
    >
      <div className="flex items-center justify-between mb-4 px-1">
        <h3 className="font-bold text-gray-700 flex items-center gap-2">
          {STATUS_LABELS[status]}
          <span className="bg-gray-200 text-gray-600 text-xs px-2 py-0.5 rounded-full">
            {tasks.length}
          </span>
        </h3>
      </div>

      <div className="flex-1 overflow-y-auto" onDragEnd={handleDragEnd}>
        {tasks.map((task) => (
          <KanbanCard key={task.id} task={task} onDragStart={handleDragStart} />
        ))}
        {tasks.length === 0 && (
          <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center text-gray-400 text-sm">
            여기에 드롭하세요
          </div>
        )}
      </div>
    </div>
  );
};

export default KanbanColumn;
```

```filepath:src/components/KanbanBoard.tsx
import React, { useState, useEffect } from 'react';
import { Task, TaskStatus } from '../types/task';
import { TaskService } from '../services/TaskService';
import KanbanColumn from './KanbanColumn';

const KanbanBoard: React.FC = () => {
  const [tasks, setTasks] = useState<Task[]>([]);
  const columns: TaskStatus[] = ['TODO', 'IN_PROGRESS', 'DONE'];

  useEffect(() => {
    setTasks(TaskService.getTasks());
  }, []);

  const handleDrop = (taskId: string, newStatus: TaskStatus) => {
    const updatedTasks = TaskService.updateStatus(taskId, newStatus);
    setTasks(updatedTasks);
  };

  return (
    <div className="p-6 bg-white min-h-screen">
      <header className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900">Project Board</h1>
        <p className="text-gray-500 mt-2">드래그 앤 드롭으로 작업의 상태를 관리하세요.</p>
      </header>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {columns.map((status) => (
          <KanbanColumn
            key={status}
            status={status}
            tasks={tasks.filter((t) => t.status === status)}
            onDrop={handleDrop}
          />
        ))}
      </div>
    </div>
  );
};

export default KanbanBoard;
```

---

### 작업 요약

#### 1. 생성/수정된 파일 목록
- `src/types/task.ts`: 데이터 구조 정의 및 타입 안정성 확보.
- `src/services/TaskService.ts`: 로컬 스토리지 데이터 영속성 관리 및 상태 업데이트 로직 분리.
- `src/components/KanbanCard.tsx`: 개별 태스크 렌더링 및 드래그 시작 이벤트 처리.
- `src/components/KanbanColumn.tsx`: 드롭 존 감지, 하이라이트 효과 및 데이터 바인딩.
- `src/components/KanbanBoard.tsx`: 전체 레이아웃 구성 및 상태 전역 관리.

#### 2. 주요 구현 결정 사항
- **HTML5 Native API 사용**: 별도의 무거운 라이브러리 없이 브라우저 내장 API를 사용하여 성능 최적화 및 번들 사이즈 감소.
- **Visual Feedback**: `isOver` 상태를 통해 드롭 가능 영역을 시각적으로 명확히 표시(파란색 하이라이트 및 링 효과).
- **상태 동기화**: 드롭 즉시 `TaskService`를 통해 로컬 스토리지에 반영하여 새로고침 시에도 데이터 유지.

#### 3. 테스트 권장 사항
- 카드를 다른 컬럼으로 드래그할 때 배경색이 변하는지 확인하세요.
- 카드를 이동시킨 후 브라우저를 새로고침하여 위치가 유지되는지 확인하세요.
- 모바일 뷰(반응형)에서 컬럼이 세로로 잘 배치되는지 확인하세요.

#### 4. 다음 단계
- 태스크 추가/삭제 기능 구현.
- 컬럼 내에서의 정렬(Ordering) 로직 추가.
- 드래그 애니메이션을 위한 `Framer Motion` 도입 검토.

추가적인 요구사항이나 수정이 필요하시면 말씀해 주세요!

---
*이 문서는 AI 에이전트에 의해 자동 생성되었습니다.*
